import { join, isAbsolute, relative } from 'node:path';
import { writeFileSync, existsSync, mkdirSync } from 'node:fs';
import ts from 'typescript';
import {
  JSONFormatter,
  MarkdownFormatter,
  SonarqubeFormatter,
  SarifFormatter,
} from './formatters/index.js';
import type {
  Report,
  ReportFormatter,
  ReportItem,
  Location,
  LintErrorLike,
  Run,
  Formatters,
} from './types.js';
import type { DiagnosticWithLocation, Node } from 'typescript';

const { DiagnosticCategory, flattenDiagnosticMessageText, SyntaxKind } = ts;

type ReporterMeta = {
  projectName: string;
  rootPath: string;
  commandName: string;
  tsVersion: string;
  stemName?: string;
  previousFixedCount?: number;
};

/**
 * Representation of diagnostic and migration report.
 */
export class Reporter {
  readonly basePath: string;

  public report: Report;
  public currentRun: Run;
  public lastRun: Run | undefined;
  private uniqueFiles: string[];
  private stemName: string;
  constructor(meta: ReporterMeta) {
    const { projectName, rootPath, commandName, tsVersion, previousFixedCount } = meta;

    // do not include extension in the stemName
    this.stemName = meta.stemName || 'rehearsal-report';
    this.basePath = rootPath;
    this.report = {
      summary: [],
      fixedItemCount: previousFixedCount || 0,
      items: [],
    };
    this.uniqueFiles = [];
    // runSummary !== summary
    // summary is a list of all runs
    // runSummary is a summary of the current run
    this.currentRun = {
      runSummary: {
        projectName,
        tsVersion,
        timestamp: '',
        basePath: '',
        entrypoint: '',
        commandName,
      },
      fixedItemCount: 0,
      items: [],
    };
  }

  public getFileNames(): string[] {
    return this.uniqueFiles;
  }

  getItemsByAnalysisTarget(fileName: string): ReportItem[] {
    return this.report.items.filter((item) => item.analysisTarget === fileName);
  }

  /**
   * Appends an element to the summary
   */
  addToRunSummary(key: string, value: unknown): void {
    this.currentRun.runSummary[key] = value;
  }

  /**
   * Appends am information about provided diagnostic and related node to the report
   */
  addTSItemToRun(
    diagnostic: DiagnosticWithLocation,
    node?: Node,
    triggeringLocation?: Location,
    hint = '',
    helpUrl = '',
    hintAdded = true
  ): void {
    this.currentRun.items.push({
      analysisTarget: this.normalizeFilePath(this.basePath, diagnostic.file.fileName),
      type: 0,
      ruleId: `TS${diagnostic.code}`,
      category: DiagnosticCategory[diagnostic.category],
      message: flattenDiagnosticMessageText(diagnostic.messageText, '. ').replace(
        this.basePath,
        '.'
      ),
      hint: hint,
      hintAdded,
      nodeKind: node ? SyntaxKind[node.kind] : undefined,
      nodeText: node?.getText(),
      helpUrl,
      nodeLocation: triggeringLocation || undefined,
    });
  }

  addLintItemToRun(fileName: string, lintError: LintErrorLike): void {
    this.currentRun.items.push({
      analysisTarget: this.normalizeFilePath(this.basePath, fileName),
      type: 1,
      // errors generated by rules or errors generated by Eslint core
      ruleId: lintError.ruleId || 'error-generated-by-Eslint-core',
      category: 'Error',
      message: lintError.message,
      hint: lintError.message,
      hintAdded: false,
      nodeKind: lintError.nodeType,
      nodeText: '',
      helpUrl: '',
      // When the error is generated by Eslint core, line and column from eslint are undefined
      // The fallback values are to prevent errors thrown by Sonarqube, e.g. endColumn has to be bigger than startColumn
      nodeLocation: {
        startLine: lintError.line || 1,
        startColumn: lintError.column || 1,
        endLine: lintError.line || 1,
        endColumn: lintError.endColumn || 2,
      },
    });
  }

  incrementRunFixedItemCount(): void {
    this.currentRun.fixedItemCount++;
  }

  saveCurrentRunToReport(runBasePath: string, runEntrypoint?: string, timestamp?: string): void {
    this.currentRun.runSummary.timestamp = timestamp || this.getTimestamp();
    this.currentRun.runSummary.basePath = runBasePath;
    this.currentRun.runSummary.entrypoint = runEntrypoint || '';
    this.report.summary = [...this.report.summary, { ...this.currentRun.runSummary }];
    this.report.fixedItemCount += this.currentRun.fixedItemCount;

    const { uniqueFiles, items } = this.mergeItems();

    this.report.items = items;
    this.uniqueFiles = uniqueFiles;
    this.lastRun = { ...this.currentRun };

    this.resetCurrentRun();
  }

  /**
   * Prints the reports using provided formatter
   * json is always printed and set as default formatter
   */
  printReport(dirPath: string, formatterTypes: Formatters[] = ['json']): string[] {
    const reports: string[] = [];
    // always print json report
    formatterTypes = Array.from(new Set([...formatterTypes, 'json']));

    formatterTypes.forEach((format) => {
      const [formatter, fileExtension] = this.getFormatter(format);
      const report = formatter(this.report);
      reports.push(report);
      const reportPath = join(dirPath, `${this.stemName}${fileExtension}`);

      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true });
      }

      // write each file as formatted to disk
      writeFileSync(reportPath, report);
    });

    return reports;
  }

  private mergeItems(): { uniqueFiles: string[]; items: ReportItem[] } {
    const fileSet = new Set<string>();
    for (const item of this.currentRun.items) {
      if (!fileSet.has(item.analysisTarget)) {
        fileSet.add(item.analysisTarget);
      }
    }
    const items = [...this.currentRun.items];
    for (const item of this.report.items) {
      if (!fileSet.has(item.analysisTarget)) {
        fileSet.add(item.analysisTarget);
        items.push(item);
      }
    }
    const uniqueFiles = Array.from(fileSet);
    return { uniqueFiles, items };
  }

  private getFormatter(formatterType: Formatters): [ReportFormatter, string] {
    // get the appropriate report from static methods of formatter
    switch (formatterType) {
      case 'json':
        return [
          (report: Report): string => JSONFormatter.getReport(report),
          JSONFormatter.extension,
        ];
      case 'sonarqube':
        return [
          (report: Report): string => SonarqubeFormatter.getReport(report),
          SonarqubeFormatter.extension,
        ];
      case 'md':
        return [
          (report: Report): string => MarkdownFormatter.getReport(report),
          MarkdownFormatter.extension,
        ];
      case 'sarif':
        return [
          (report: Report): string => SarifFormatter.getReport(report),
          SarifFormatter.extension,
        ];
      default:
        break;
    }

    throw new Error(`Unknown formatter: ${formatterType}`);
  }

  private resetCurrentRun(): void {
    this.currentRun.runSummary.timestamp = '';
    this.currentRun.runSummary.basePath = '';
    this.currentRun.runSummary.entrypoint = '';
    this.currentRun.fixedItemCount = 0;
    this.currentRun.items = [];
  }

  private getTimestamp(): string {
    return new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
      hourCycle: 'h24',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });
  }

  private normalizeFilePath(basePath: string, filepath: string): string {
    if (isAbsolute(filepath)) {
      return relative(basePath, filepath);
    }

    return filepath;
  }
}

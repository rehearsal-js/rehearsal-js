import fs from 'fs';
import path from 'path';
import glob from 'glob';

/** @typedef {{
    category: string;
    code: number;
    reportsUnnecessary?: {};
    reportsDeprecated?: {};
    isEarly?: boolean;
    elidedInCompatabilityPyramid?: boolean;
}} DiagnosticDetails */
void 0;

/** @typedef {Map<string, DiagnosticDetails>} InputDiagnosticMessageTable */

async function main() {
  if (process.argv.length < 3) {
    console.log('Usage:');
    console.log('\tnode processDiagnosticMessages.mjs <diagnostic-json-input-file>');
    return;
  }

  const diagnosticMessagesJson = await writeDiagnostics();

  await writeCodefixes(diagnosticMessagesJson);
}

async function writeDiagnostics() {
  const diagnosticsInputFilePath = process.argv[2].replace(/\\/g, '/');
  console.log(`Reading diagnostics from ${diagnosticsInputFilePath}`);
  const diagnosticInputStr = await fs.promises.readFile(diagnosticsInputFilePath, { encoding: 'utf-8' });

  /** @type {{ [key: string]: DiagnosticDetails }} */
  const diagnosticMessagesJson = JSON.parse(diagnosticInputStr);

  /** @type {InputDiagnosticMessageTable} */
  const diagnosticMessages = new Map();
  for (const key in diagnosticMessagesJson) {
    if (Object.hasOwnProperty.call(diagnosticMessagesJson, key)) {
      diagnosticMessages.set(key, diagnosticMessagesJson[key]);
    }
  }

  const diagnosticOutput = buildDiagnosticFileOutput(diagnosticMessages, diagnosticsInputFilePath);
  checkForUniqueCodes(diagnosticMessages);
  await writeFile(diagnosticsInputFilePath, 'diagnosticInformationMap.generated.ts', diagnosticOutput);

  return diagnosticMessagesJson;
}

async function writeCodefixes(diagnosticMessagesJson) {
  const codeFixInputPath = process.argv[3].replace(/\\/g, '/');
  console.log(`Reading codefixes from ${codeFixInputPath}`);
  const inputStr = await fs.promises.readFile(codeFixInputPath, { encoding: 'utf-8' });

  /** @type {{ [key: string]: DiagnosticDetails }} */
  const codefixJson = JSON.parse(inputStr);

  /** @type {InputDiagnosticMessageTable} */
  const codeFixMessages = new Map();
  for (const key in codefixJson) {
    if (Object.hasOwnProperty.call(codefixJson, key)) {
      codeFixMessages.set(key, codefixJson[key]);
    }
  }
  const fixes = path.resolve(path.dirname(codeFixInputPath), path.join('..', 'test', 'fixtures', 'ts-codefixes'));

  const codeFixOutput = buildCodeFixFileOutput(codeFixMessages, codeFixInputPath, diagnosticMessagesJson, fixes);

  await writeFile(codeFixInputPath, 'codefixInformationMap.generated.ts', codeFixOutput);
  await writeMarkdown(codeFixMessages, fixes);
}

/**
 * @param {InputDiagnosticMessageTable} diagnosticTable
 */
function checkForUniqueCodes(diagnosticTable) {
  /** @type {Record<number, true | undefined>} */
  const allCodes = [];
  diagnosticTable.forEach(({ code }) => {
    if (allCodes[code]) {
      throw new Error(`Diagnostic code ${code} appears more than once.`);
    }
    allCodes[code] = true;
  });
}

/**
 * @param {InputDiagnosticMessageTable} messageTable
 * @param {string} inputFilePathRel
 * @returns {string}
 */
function buildDiagnosticFileOutput(messageTable, inputFilePathRel) {
  const result = [
    '// <auto-generated />',
    `// generated from '${inputFilePathRel}'`,
    '',
    'export interface DiagnosticMessage {',
    `  category: 'Warning' | 'Error' | 'Suggestion' | 'Message';`,
    '  code: number;',
    '  message: string;',
    '}',
    '',
    '/** Represents all the diagnostic codes from within TypeScript.',
    '@internal',
    '*/',
    '',
    'export const Diagnostics = {',
  ];
  messageTable.forEach(
    (
      { code, category },
      name
    ) => {
      const escapedName = name.replace(/[\\$'"]/g, '\\$&').replace(/\//g, '\\/')
      result.push(
        `    /** ${category}:TS${code} ${escapedName} **/`,
        `    TS${code}: { code: ${code}, category: "${category}", message: "${escapedName}" },`
      );
    }
  );

  result.push('} as const;');

  return result.join('\r\n');
}

/**
 * @param {InputDiagnosticMessageTable} messageTable
 * @returns {string}
 */
function buildDiagnosticMessageOutput(messageTable) {
  /** @type {Record<string, string>} */
  const result = {};

  messageTable.forEach(({ code }, name) => {
    const propName = convertPropertyName(name);
    result[createKey(propName, code)] = name;
  });

  return JSON.stringify(result, undefined, 2).replace(/\r?\n/g, '\r\n');
}

/**
 *
 * @param {string} name
 * @param {number} code
 * @returns {string}
 */
function createKey(name, code) {
  return name.slice(0, 100) + '_' + code;
}

/**
 * @param {string} origName
 * @returns {string}
 */
function convertPropertyName(origName) {
  let result = origName
    .split('')
    .map((char) => {
      if (char === '*') return '_Asterisk';
      if (char === '/') return '_Slash';
      if (char === ':') return '_Colon';
      return /\w/.test(char) ? char : '_';
    })
    .join('');

  // get rid of all multi-underscores
  result = result.replace(/_+/g, '_');

  // remove any leading underscore, unless it is followed by a number.
  result = result.replace(/^_([^\d])/, '$1');

  // get rid of all trailing underscores.
  result = result.replace(/_$/, '');

  return result;
}

async function writeMarkdown(codeFixMessages, fixes) {
  let buffer = '';
  let fixesCounter = 1;
  let diagnostics = [];

  codeFixMessages.forEach((fix, name, i) => {
    buffer += `## ${fix.title}\n\nid: _${name}_\n\n${fix.description}\n${writeCases(name, fixes)}\n\n\n`

    diagnostics = diagnostics.concat(fix.diagnostics);
    fixesCounter++;
  });

  const diagnosticsCounter = [...new Set(diagnostics)].length;
  const result = [
    '# Supported CodeFixes',
    '',
    `The following ${fixesCounter} codefixes are supported by Rehearsal, which resolve ${diagnosticsCounter} different TypeScript diagnostics errors.`,
    '',
    buffer
  ].join('\n');
  await fs.promises.writeFile('Supported-Fixes.md', result);
}

function buildCodeFixFileOutput(messageTable, inputFilePathRel, diagnosticJson, fixes) {
  const result = [
    '// <auto-generated />',
    `// generated from '${inputFilePathRel}'`,
    '',
    `import { Diagnostics, DiagnosticMessage } from './diagnosticInformationMap.generated.js'; `,
    '',
    'export interface CodefixMessage {',
    '  name: string;',
    '  title: string;',
    '  description: string;',
    '  builtIn: boolean;',
    '  diagnostics: DiagnosticMessage[];',
    '}',
    '',
    'function fix(name: string, title: string, description: string, diagnostics:  DiagnosticMessage[], builtIn: boolean): CodefixMessage {',
    '    return { name, title, description, diagnostics, builtIn };',
    '}',
    '',
    '/** @internal */',
    'export const CodeFixes = {',
  ];
  messageTable.forEach(
    (
      { title, description, diagnostics, builtIn },
      name
    ) => {
      result.push(
        `    ${name}: fix('${name}', "${title}", "${description}", [${createDiagnostics(diagnostics, diagnosticJson)}], ${builtIn ? builtIn : false}), `
      );
    }
  );

  result.push('};');

  return result.join('\r\n');
}

function byCode(diagnosticJson) {
  const out = {};
  Object.entries(diagnosticJson).forEach(([key, value]) => {
    out[value.code] = convertPropertyName(key);
  })
  return out;
}

function writeCases(name, fixes) {
  const passing = glob.sync(`${path.join(fixes, name, 'passing')}/*.ts`).map(file => fs.readFileSync(file, 'utf-8'));
  const failing = glob.sync(`${path.join(fixes, name, 'failing')}/*.ts`).map(file => fs.readFileSync(file, 'utf-8'));

  return failing.length > 0 ? `**Input:**\n\n${failing.map(fail => '```ts\n' + fail + '\n```').join('\n')}\n**Output:**\n\n${passing.map(pass => '```ts\n' + pass + '\n```').join('\n')}` : ''
}

function createDiagnostics(diagnostics, diagnosticJson) {
  const diagnosticsByCode = byCode(diagnosticJson);
  return diagnostics.map((code) => `Diagnostics.TS${code}`).join(',');
}

/**
 * @param {string} fileName
 * @param {string} contents
 */
async function writeFile(from, fileName, contents) {
  const filePath = path.join(path.dirname(from), fileName);
  try {
    const existingContents = await fs.promises.readFile(filePath, 'utf-8');
    if (existingContents === contents) {
      return;
    }
  } catch {
    // Just write the file.
  }

  await fs.promises.writeFile(filePath, contents, { encoding: 'utf-8' });
}

main();

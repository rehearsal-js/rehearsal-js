import fs from 'fs';
import path from 'path';

/** @typedef {{
    category: string;
    code: number;
    reportsUnnecessary?: {};
    reportsDeprecated?: {};
    isEarly?: boolean;
    elidedInCompatabilityPyramid?: boolean;
}} DiagnosticDetails */
void 0;

/** @typedef {Map<string, DiagnosticDetails>} InputDiagnosticMessageTable */

async function main() {
  if (process.argv.length < 4) {
    console.log('Usage:');
    console.log('\tnode processCodeFixes.mjs <codefix-json-input-file> <path_to_diagnostics_map>');
    return;
  }

  /**
   * @param {string} fileName
   * @param {string} contents
   */
  async function writeFile(fileName, contents) {
    const filePath = path.join(path.dirname(inputFilePath), fileName);
    try {
      const existingContents = await fs.promises.readFile(filePath, 'utf-8');
      if (existingContents === contents) {
        return;
      }
    } catch {
      // Just write the file.
    }

    await fs.promises.writeFile(filePath, contents, { encoding: 'utf-8' });
  }

  const inputFilePath = process.argv[2].replace(/\\/g, '/');
  console.log(`Reading codefixes from ${inputFilePath}`);
  const inputStr = await fs.promises.readFile(inputFilePath, { encoding: 'utf-8' });

  /** @type {{ [key: string]: DiagnosticDetails }} */
  const codefixJson = JSON.parse(inputStr);

  /** @type {InputDiagnosticMessageTable} */
  const codeFixMessages = new Map();
  for (const key in codefixJson) {
    if (Object.hasOwnProperty.call(codefixJson, key)) {
      codeFixMessages.set(key, codefixJson[key]);
    }
  }

  const diagnosticPath = process.argv[3].replace(/\\/g, '/');
  const diagnosticJson = byCode(JSON.parse(await fs.promises.readFile(diagnosticPath, { encoding: 'utf-8' })));
  const infoFileOutput = buildInfoFileOutput(codeFixMessages, inputFilePath, diagnosticJson);
  await writeFile('codefixInformationMap.generated.ts', infoFileOutput);

  await writeMarkdown(codeFixMessages)
}

/**
 * @param {InputDiagnosticMessageTable} diagnosticTable
 */
function checkForUniqueCodes(diagnosticTable) {
  /** @type {Record<number, true | undefined>} */
  const allCodes = [];
  diagnosticTable.forEach(({ code }) => {
    if (allCodes[code]) {
      throw new Error(`Diagnostic code ${code} appears more than once.`);
    }
    allCodes[code] = true;
  });
}

/**
 * @param {InputDiagnosticMessageTable} messageTable
 * @param {string} inputFilePathRel
 * @returns {string}
 */
function buildInfoFileOutput(messageTable, inputFilePathRel, diagnosticJson) {
  const result = [
    '// <auto-generated />',
    `// generated from '${inputFilePathRel}'`,
    '',
    `import { Diagnostics, DiagnosticMessage } from './diagnosticInformationMap.generated.js'; `,
    '',
    'export interface CodefixMessage {',
    '  name: string;',
    '  title: string;',
    '  description: string;',
    '  passing: string[];',
    '  failing: string[];',
    '  diagnostics: DiagnosticMessage[];',
    '}',
    '',
    'function fix(name: string, title: string, description: string, diagnostics:  DiagnosticMessage[], passing: string[], failing: string[]): CodefixMessage {',
    '    return { name, title, description, passing, failing, diagnostics };',
    '}',
    '',
    '/** @internal */',
    'export const CodeFixes = {',
  ];
  messageTable.forEach(
    (
      { title, description, passing, failing, diagnostics },
      name
    ) => {

      result.push(
        `    ${name}: fix('${name}', '${title}', '${description}', [${createDiagnostics(diagnostics, diagnosticJson)}], ${JSON.stringify(
          passing
        )}, ${JSON.stringify(
          failing
        )}), `
      );
    }
  );

  result.push('};');

  return result.join('\r\n');
}

/**
 * @param {InputDiagnosticMessageTable} messageTable
 * @returns {string}
 */
function buildDiagnosticMessageOutput(messageTable) {
  /** @type {Record<string, string>} */
  const result = {};

  messageTable.forEach(({ code }, name) => {
    const propName = convertPropertyName(name);
    result[createKey(propName, code)] = name;
  });

  return JSON.stringify(result, undefined, 2).replace(/\r?\n/g, '\r\n');
}

function createDiagnostics(diagnostics, diagnosticJson) {
  return diagnostics.map((code) => `Diagnostics.${diagnosticJson[code]}`).join(',');
}

/**
 *
 * @param {string} name
 * @param {number} code
 * @returns {string}
 */
function createKey(name, code) {
  return name.slice(0, 100) + '_' + code;
}

/**
 * @param {string} origName
 * @returns {string}
 */
function convertPropertyName(origName) {
  let result = origName
    .split('')
    .map((char) => {
      if (char === '*') return '_Asterisk';
      if (char === '/') return '_Slash';
      if (char === ':') return '_Colon';
      return /\w/.test(char) ? char : '_';
    })
    .join('');

  // get rid of all multi-underscores
  result = result.replace(/_+/g, '_');

  // remove any leading underscore, unless it is followed by a number.
  result = result.replace(/^_([^\d])/, '$1');

  // get rid of all trailing underscores.
  result = result.replace(/_$/, '');

  return result;
}


function byCode(diagnosticJson) {
  const out = {};
  Object.entries(diagnosticJson).forEach(([key, value]) => {
    out[value.code] = convertPropertyName(key);
  })
  return out;
}

async function writeMarkdown(codeFixMessages) {
  let buffer = '';
  codeFixMessages.forEach(fix => {
    buffer += `## ${fix.title}\n${fix.description}\n\n**Input:**\n${fix.failing.map(fail => '```ts\n' + fail + '\n```').join('\n')}\n**Output:**\n${fix.passing.map(pass => '```ts\n' + pass + '\n```').join('\n')}\n\n`
  })
  const result = [
    '# Supported CodeFixes',
    '',
    'The following codefixes are supported by Rehearsal.',
    '',
    buffer
  ].join('\n');
  await fs.promises.writeFile('Supported-Fixes.md', result);
}

main();
